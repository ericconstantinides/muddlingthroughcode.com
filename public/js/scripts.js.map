{"version":3,"sources":["scripts.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","init","items","forEach","item","activationTargets","concat","d","querySelectorAll","getAttribute","hasViewportActivatingAtTop","hasAttribute","isActivatingAtBottom","isKeepingActive","manualOffset","offset","isNaN","offsetEl","querySelector","Number","scrollOverItem","w","setTimeout","checkScrollState","addEventListener","changeState","direction","callee","_this","this","isSameNode","isActive","classList","add","remove","target","call","contains","currentPxFromTop","getBoundingClientRect","top","offsetHeight","innerHeight","currentPxFromBottom","diffFromTop","ratioFromTop","style","opacity","window","document","getElementsByClassName"],"mappings":"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","file":"scripts.js","sourcesContent":["/**\n * Scroll Activation\n *\n * Summary\n *   Scroll Activation makes an element \"active\" when the top of its container\n *   is scrolled upon\n *\n * Usage\n *   .js-scroll-activation\n *      Add this class to the element you want to be the target of activation\n *\n * Element Options\n *    [data-keep-this-active]\n *      Keeps the item always active once activated; otherwise, the active\n *      will be removed after going back up.\n *    [data-target=\"TARGET_ID\"]\n *      Add to the target element and any element you want to set 'is-active'.\n *      Be sure to use matching TARGET_IDs\n *    [data-activate-viewport-at-top]\n *      Activation matching occurs at the top of the viewport/window instead\n *      of the bottom\n *    [data-activate-this-at-bottom]\n *      Activation matching occurs at the bottom of the element instead of the\n *      top\n *    [data-manual-offset=\"NUMBER\"] -or- [data-manual-offset=\"QUERY-SELECTOR\"]\n *      Either:\n *       option 1. Offset by a NUMBER of pixels. Do not include \"px\".\n *       option 2. Offset by an element (like a header) using a QUERY-SELECTOR\n *    [data-scroll-over=\"QUERY-SELECTOR\"]\n *      Will gradually fade the opacity of the \"scroll-over\" element once the\n *      primary element is within the scroll-over's top and bottom\n *\n * Creates\n *   .is-active\n *      This class gets added to both the .js-scroll-activation class and the\n *      [data-target=\"TARGET_ID\"]\n */\n\n;(function () {\n  // cache the goods\n  let w = window\n  let d = document\n  let items = [...d.getElementsByClassName('js-scroll-activation')]\n\n  function init () {\n    if (items.length) {\n      items.forEach(item => {\n        // cache all the constant variables:\n        item.activationTargets = [...(d.querySelectorAll('[data-target=' + item.getAttribute('data-target') + ']'))]\n        item.hasViewportActivatingAtTop = !!item.hasAttribute('data-activate-viewport-at-top')\n        item.isActivatingAtBottom = !!item.hasAttribute('data-activate-this-at-bottom')\n        item.isKeepingActive = !!item.hasAttribute('data-keep-this-active')\n\n        // get the manual offset or if necessary, prepare the offsetElement\n        item.manualOffset = 0\n        if (item.hasAttribute('data-manual-offset')) {\n          let offset = item.getAttribute('data-manual-offset')\n          if (isNaN(offset)) {\n            let offsetEl = d.querySelector(offset)\n            if (offsetEl) { item.offsetEl = offsetEl } else { item.manualOffset = Number(offset) }\n          }\n        }\n        if (item.hasAttribute('data-scroll-over')) {\n          let scrollOverItem = d.querySelector(item.getAttribute('data-scroll-over'))\n          if (scrollOverItem) item.scrollOverItem = scrollOverItem\n        }\n      })\n\n      // wait half a second for other page items to finish\n      w.setTimeout(() => checkScrollState(items), 500)\n\n      // add the scroll listener\n      d.addEventListener('scroll', () => checkScrollState(items))\n    }\n  }\n\n  // perform as few hits to the DOM as necessary\n  function changeState (direction, callee) {\n    if (callee && this.isSameNode(callee)) return\n    if (direction === 'activate') {\n      if (!this.isActive) {\n        this.classList.add('is-active')\n        this.isActive = true\n      }\n    } else {\n      if (this.isActive) {\n        this.classList.remove('is-active')\n        this.isActive = false\n      }\n    }\n    if (this.activationTargets && this.activationTargets.length) {\n      this.activationTargets.forEach(target => changeState.call(target, direction, this))\n    }\n  }\n\n  // cycles through the scroll state of items and ajusts if necessary\n  function checkScrollState (items) {\n    items.forEach((item) => {\n      // don't bother running if it's already active and keep-active is set:\n      if (!item.isKeepingActive || !item.classList.contains('is-active')) {\n        // get the items current top position:\n        item.currentPxFromTop = item.getBoundingClientRect().top\n\n        // get the height of the offsetEl\n        if (typeof item.offsetEl !== 'undefined') { item.manualOffset = item.offsetEl.offsetHeight }\n        if (item.isActivatingAtBottom) {\n          item.offset = item.manualOffset - item.offsetHeight\n        } else {\n          item.offset = item.manualOffset\n        }\n\n        // is executing at the top of the viewport:\n        if (item.hasViewportActivatingAtTop) {\n          if (item.currentPxFromTop <= item.offset) {\n            changeState.call(item, 'activate')\n          } else {\n            changeState.call(item, 'deactivate')\n          }\n        } else { // is executing at the bottom of the viewport:\n          // take the items pixels from top, minus the height of the viewport, minus any manual Offset:\n          if (item.currentPxFromTop - item.offset < w.innerHeight) {\n            changeState.call(item, 'activate')\n          } else {\n            changeState.call(item, 'deactivate')\n          }\n        }\n\n        if (item.scrollOverItem) {\n          item.scrollOverItem.currentPxFromTop =\n            item.scrollOverItem.getBoundingClientRect().top\n          item.scrollOverItem.currentPxFromBottom =\n            item.scrollOverItem.currentPxFromTop + item.scrollOverItem.offsetHeight\n          // the decimal values are to not start or finish unless we're in the zone a little bit extra\n          if (item.currentPxFromTop < item.scrollOverItem.currentPxFromBottom - item.scrollOverItem.offsetHeight * 0.1 &&\n            item.currentPxFromTop > item.scrollOverItem.currentPxFromTop) {\n            // we're in the middle zone, so we have to figure out how far we are\n            // so we could either do it from the bottom or the top\n            let diffFromTop = item.currentPxFromTop - item.scrollOverItem.currentPxFromTop -\n              item.scrollOverItem.offsetHeight * 0.15\n            let ratioFromTop = diffFromTop / (item.scrollOverItem.offsetHeight - item.scrollOverItem.offsetHeight * 0.15)\n            item.scrollOverItem.style.opacity = ratioFromTop\n            // so now we have ratioFromTop\n          } else {\n            item.scrollOverItem.style.opacity = 1\n          }\n        }\n      }\n    })\n  }\n\n  init(items)\n})()\n"],"sourceRoot":"src/js"}