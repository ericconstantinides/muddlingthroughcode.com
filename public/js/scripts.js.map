{"version":3,"sources":["scripts.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","init","items","forEach","item","activationTargets","concat","d","querySelectorAll","getAttribute","hasViewportActivatingAtTop","hasAttribute","isActivatingAtBottom","isKeepingActive","manualOffset","offset","isNaN","offsetEl","querySelector","Number","w","setTimeout","checkScrollState","addEventListener","changeState","direction","callee","_this","this","isSameNode","isActive","classList","add","remove","target","call","contains","currentPxFromTop","getBoundingClientRect","top","offsetHeight","innerHeight","window","document","getElementsByClassName"],"mappings":"AAAA,YAEA,SAASA,oBAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAOC,EAAKD,GAAKH,EAAIG,EAAM,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,IAkCzL,WAOC,QAASO,KACHC,EAAMH,SACRG,EAAMC,QAAQ,SAAAC,GASZ,GAPAA,EAAKC,qBAALC,OAAAb,mBAA8Bc,EAAEC,iBAAiB,gBAAkBJ,EAAKK,aAAa,eAAiB,OACtGL,EAAKM,6BAA6BN,EAAKO,aAAa,iCACpDP,EAAKQ,uBAAuBR,EAAKO,aAAa,gCAC9CP,EAAKS,kBAAkBT,EAAKO,aAAa,yBAGzCP,EAAKU,aAAe,EAChBV,EAAKO,aAAa,sBAAuB,CAC3C,GAAII,GAASX,EAAKK,aAAa,qBAC/B,IAAIO,MAAMD,GAAS,CACjB,GAAIE,GAAWV,EAAEW,cAAcH,EAC3BE,GACFb,EAAKa,SAAWA,EAEhBb,EAAKU,aAAeK,OAAOJ,OAMnCK,EAAEC,WAAW,WAAA,MAAMC,GAAiBpB,IAAQ,KAG5CK,EAAEgB,iBAAiB,SAAW,WAAA,MAAMD,GAAiBpB,MAKzD,QAASsB,GAAaC,EAAWC,GAAQ,GAAAC,GAAAC,IACnCF,IAAUE,KAAKC,WAAWH,KACZ,aAAdD,EACGG,KAAKE,WACRF,KAAKG,UAAUC,IAAI,aACnBJ,KAAKE,UAAW,GAGdF,KAAKE,WACPF,KAAKG,UAAUE,OAAO,aACtBL,KAAKE,UAAW,GAGhBF,KAAKvB,mBAAqBuB,KAAKvB,kBAAkBN,QACnD6B,KAAKvB,kBAAkBF,QAAQ,SAAA+B,GAAA,MAAUV,GAAYW,KAAKD,EAAQT,EAAzBE,MAK7C,QAASL,GAAkBpB,GACzBA,EAAMC,QAAQ,SAACC,GAERA,EAAKS,iBAAoBT,EAAK2B,UAAUK,SAAS,eAGpDhC,EAAKiC,iBAAmBjC,EAAKkC,wBAAwBC,IAG/B,cAAlBnC,EAAKa,WACPb,EAAKU,aAAeV,EAAKa,SAASuB,cAEhCpC,EAAKQ,qBACPR,EAAKW,OAASX,EAAKU,aAAeV,EAAKoC,aAEvCpC,EAAKW,OAASX,EAAKU,aAGjBV,EAAKM,2BACHN,EAAKiC,kBAAoBjC,EAAKW,OAChCS,EAAYW,KAAK/B,EAAK,YAEtBoB,EAAYW,KAAK/B,EAAK,cAKpBA,EAAKiC,iBAAmBjC,EAAKW,OAASK,EAAEqB,YAC1CjB,EAAYW,KAAK/B,EAAK,YAEtBoB,EAAYW,KAAK/B,EAAK,iBArFhC,GAAIgB,GAAIsB,OACJnC,EAAIoC,SACJzC,KAAAA,OAAAA,mBAAYK,EAAEqC,uBAAuB,yBAyFzC3C,GAAKC","file":"scripts.js","sourcesContent":["//------------------------------------------------------------------------------\n//\n//  Scroll Activation\n//\n//  Summary\n//    Scroll Activation makes an element \"active\" when the top of its container\n//    is scrolled upon\n//\n//  Usage\n//    .js-scroll-activation\n//       Add this class to the element you want to be the target of activation\n//\n//  Element Options\n//     [data-keep-this-active]\n//       Keeps the item always active once activated; otherwise, the active\n//       will be removed after going back up.\n//     [data-target=\"TARGET_ID\"]\n//       Add to the target element and any element you want to set 'is-active'.\n//       Be sure to use matching TARGET_IDs\n//     [data-activate-viewport-at-top]\n//       Activation matching occurs at the top of the viewport/window instead\n//       of the bottom\n//     [data-activate-this-at-bottom]\n//       Activation matching occurs at the bottom of the element instead of the\n//       top\n//     [data-manual-offset=\"NUMBER\"] -or- [data-manual-offset=\"QUERY-SELECTOR\"]\n//       Either:\n//        option 1. Offset by a NUMBER of pixels. Do not include \"px\".\n//        option 2. Offset by an element (like a header) using a QUERY-SELECTOR\n//\n//  Creates\n//    .is-active\n//       This class gets added to both the .js-scroll-activation class and the\n//       [data-target=\"TARGET_ID\"]\n//\n//------------------------------------------------------------------------------\n;(function() {\n\n  // cache the goods\n  let w = window\n  let d = document;\n  let items = [...d.getElementsByClassName('js-scroll-activation')]\n\n  function init() {\n    if (items.length) {\n      items.forEach(item => {\n        // cache all the constant variables:\n        item.activationTargets = [...(d.querySelectorAll('[data-target=' + item.getAttribute('data-target') + ']'))]\n        item.hasViewportActivatingAtTop = item.hasAttribute('data-activate-viewport-at-top') ? true : false\n        item.isActivatingAtBottom = item.hasAttribute('data-activate-this-at-bottom') ? true : false\n        item.isKeepingActive = item.hasAttribute('data-keep-this-active') ? true : false\n\n        // get the manual offset or if necessary, prepare the offsetElement\n        item.manualOffset = 0;\n        if (item.hasAttribute('data-manual-offset')) {\n          let offset = item.getAttribute('data-manual-offset');\n          if (isNaN(offset)) {\n            let offsetEl = d.querySelector(offset);\n            if (offsetEl)\n              item.offsetEl = offsetEl\n            else\n              item.manualOffset = Number(offset)\n          }\n        }\n      })\n\n      // wait half a second for other page items to finish\n      w.setTimeout(() => checkScrollState(items), 500)\n\n      // add the scroll listener\n      d.addEventListener('scroll', (() => checkScrollState(items)))\n    }\n  }\n\n  // perform as few hits to the DOM as necessary\n  function changeState (direction, callee) {\n    if (callee && this.isSameNode(callee)) return\n    if (direction === 'activate') {\n      if (!this.isActive) {\n        this.classList.add('is-active')\n        this.isActive = true\n      }\n    } else {\n      if (this.isActive) {\n        this.classList.remove('is-active')\n        this.isActive = false\n      }\n    }\n    if (this.activationTargets && this.activationTargets.length) {\n      this.activationTargets.forEach(target => changeState.call(target, direction, this))\n    }\n  }\n\n  // cycles through the scroll state of items and ajusts if necessary\n  function checkScrollState (items) {\n    items.forEach((item) => {\n      // don't bother running if it's already active and keep-active is set:\n      if (!item.isKeepingActive || !item.classList.contains('is-active')) {\n\n        // get the items current top position:\n        item.currentPxFromTop = item.getBoundingClientRect().top\n\n        // get the height of the offsetEl\n        if (item.offsetEl !== 'undefined')\n          item.manualOffset = item.offsetEl.offsetHeight\n\n        if (item.isActivatingAtBottom)\n          item.offset = item.manualOffset - item.offsetHeight;\n        else\n          item.offset = item.manualOffset\n\n        // is executing at the top of the viewport:\n        if (item.hasViewportActivatingAtTop) {\n          if (item.currentPxFromTop <= item.offset )\n            changeState.call(item,'activate')\n          else\n            changeState.call(item,'deactivate')\n        }\n        // is executing at the bottom of the viewport:\n        else {\n          // take the items pixels from top, minus the height of the viewport, minus any manual Offset:\n          if (item.currentPxFromTop - item.offset < w.innerHeight)\n            changeState.call(item,'activate')\n          else\n            changeState.call(item,'deactivate')\n        }\n      }\n    })\n  }\n\n  init(items)\n})()"],"sourceRoot":"frontend/scripts"}